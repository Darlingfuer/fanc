#!/usr/bin/env python

import argparse
import os.path
import textwrap
import sys
import shutil
import tempfile

import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')


class Kaic(object):

    def __init__(self):
        usage = '''\
                kaic <command> [options]

                Commands:

                    --- Mapping
                    iterative_mapping  Iteratively map a FASTQ file to a Bowtie 2 index

                    --- Reads
                    load_reads         Load a SAM/BAM file into a Reads object
                    filter_reads       Filter a Reads object

                    -- Genome
                    build_genome       Convenience command to build a Genome object

                    --- Pairs
                    reads_to_pairs     Convert a Reads object into a Pairs object
                    filter_pairs       Filter a Pairs object

                    --- Hic
                    pairs_to_hic       Convert a pairs object into a Hic object
                    filter_hic         Filter a Hic object
                    merge_hic          Merge multiple Hic objects
                    bin_hic            Bin a Hic object into same-size regions
                    correct_hic        Correct a Hic object for biases

                    --- Network
                    call_peaks         Call enriched peaks in a Hic object

                    --- Plotting
                    plot_ligation_err  Plot the ligation error of a Pairs object
                    plot_re_dist       Plot the distance of reads to the nearest RE site
                    plot_hic_corr      Plot the correlation of two Hic objects
                    plot_hic_matrix    Plot a Hic matrix
                    plot_hic_marginals Plot marginals in a Hic object
                    plot_diff          Plot the difference between two Hic matrices
                    plot_ratio         Plot the ratio between two Hic matrices

                    --- Other
                    hiclib_to_kaic     Convert a hiclib object to a Hic object

                Run kaic <command> -h for help on a specific command.
                '''
        parser = argparse.ArgumentParser(
            description="kaic processing tool for Hi-C data",
            usage=textwrap.dedent(usage)
        )

        parser.add_argument('command', help='Subcommand to run')

        # parse_args defaults to [1:] for args, but you need to
        # exclude the rest of the args too, or validation will fail
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print 'Unrecognized command'
            parser.print_help()
            exit(1)
        # use dispatch pattern to invoke method with same name
        getattr(self, args.command)()

    ##########################################################################
    #
    #                                  Mapping
    #
    ##########################################################################

    def iterative_mapping(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Iteratively map a FASTQ file to a Bowtie 2 index'
        )
        bc = os.popen('which bowtie2')
        bowtie_path = bc.read().rstrip()

        def split_list(this_list):
            return this_list.split(",")

        parser.add_argument(
            'input',
            type=split_list,
            help='''Input FASTQ files (comma-separated)'''
        )

        parser.add_argument(
            'index',
            help='''Bowtie 2 index (include prefix)'''
        )

        parser.add_argument(
            'output',
            type=split_list,
            help='''Output files (must be same number as input files)'''
        )

        parser.add_argument(
            '-b', '--bowtie', dest='bowtie',
            default=bowtie_path,
            help='''Bowtie 2 executable path (will check PATH variable by default)'''
        )

        parser.add_argument(
            '-bo', '--bowtie2-options', dest='bowtie2_options',
            default='--very-sensitive --no-unal',
            help='''Bowtie 2 command line options, default: --very-sensitive --no-unal'''
        )

        parser.add_argument(
            '-m', '--min-length', dest='min_length',
            type=int,
            default=25,
            help='''Minimum sequence length to attempt the mapping'''
        )

        parser.add_argument(
            '-s', '--step', dest='step',
            type=int,
            default=2,
            help='''Step size to increase mapped sequence length'''
        )

        parser.add_argument(
            '-t', '--threads', dest='threads',
            type=int,
            default=8,
            help='''Number of threads'''
        )

        parser.add_argument(
            '-tmp', '--temp-dir', dest='tmp',
            default="/tmp",
            help='''Temporary directory'''
        )

        parser.add_argument(
            '-nj', '--no-join', dest='join',
            action='store_false',
            help='''Do not join partial SAM files into a single file'''
        )
        parser.set_defaults(join=True)

        parser.add_argument(
            '-nc', '--no-clean', dest='clean',
            action='store_false',
            help='''Do not delete partial SAM files (*.sam.\d)'''
        )
        parser.set_defaults(clean=True)

        args = parser.parse_args(sys.argv[2:])

        from kaic.mapping.iterative_mapping import iterative_mapping

        iterative_mapping(args.input, args.output, args.index, args.bowtie, args.min_length, args.step,
                          args.threads, args.tmp, args.join, args.clean, args.bowtie2_options)

    ##########################################################################
    #
    #                                  Reads
    #
    ##########################################################################

    def load_reads(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Load a SAM/BAM file into a Reads object'
        )

        parser.add_argument(
            'input',
            help='''Input SAM file'''
        )

        parser.add_argument(
            'output',
            help='''Output file'''
        )

        parser.add_argument(
            '-N', '--ignore-qname', dest='qname',
            action='store_false',
            help='''Do not store a read's qname, only a hashed version will be stored internally.'''
        )
        parser.set_defaults(qname=True)

        parser.add_argument(
            '-Q', '--ignore-qual', dest='qual',
            action='store_false',
            help='''Do not store a read's quality string.'''
        )
        parser.set_defaults(qual=True)

        parser.add_argument(
            '-S', '--ignore-seq', dest='seq',
            action='store_false',
            help='''Do not store a read's sequence string.'''
        )
        parser.set_defaults(seq=True)

        parser.add_argument(
            '-C', '--ignore-cigar', dest='cigar',
            action='store_false',
            help='''Do not store a read's cigar string. Warning: Some filters rely on this attribute.'''
        )
        parser.set_defaults(cigar=True)

        parser.add_argument(
            '-T', '--ignore-tags', dest='tags',
            action='store_false',
            help='''Do not store a read's tags. Warning: Some filters rely on this attribute.'''
        )
        parser.set_defaults(tags=True)

        parser.add_argument(
            '-D', '--ignore-default', dest='ignore_default',
            action='store_true',
            help='''Ignore qname, seq, and qual information to speed up read loading.'''
        )
        parser.set_defaults(ignore_default=False)

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.files import create_temporary_copy

        input_path = os.path.expanduser(args.input)
        if args.tmp:
            logging.info("Creating copy to work in temporary folder...")
            input_path = create_temporary_copy(input_path, preserve_extension=True)
            logging.info("Copy created in %s" % input_path)

        output_path = os.path.expanduser(args.output)
        original_output_path = output_path
        if args.tmp:
            tmp_file = tempfile.NamedTemporaryFile(delete=False)
            tmp_file.close()
            output_path = tmp_file.name
            logging.info("Output temporarily redirected to %s" % output_path)

        if args.ignore_default is True:
            store_qname = False
            store_seq = False
            store_qual = False
            store_cigar = True
            store_tags = True
        else:
            store_qname = args.qname
            store_seq = args.seq
            store_qual = args.qual
            store_cigar = args.cigar
            store_tags = args.tags

        logging.info("Starting to import file %s" % input_path)
        reads = kaic.Reads(file_name=output_path, mode='w')
        reads.load(sambam=input_path, store_cigar=store_cigar, store_seq=store_seq, store_qname=store_qname,
                   store_qual=store_qual, store_tags=store_tags, sample_size=100000)
        reads.close()

        if args.tmp:
            logging.info("Removing temporary file...")
            os.unlink(input_path)
            logging.info("Moving output file to destination...")
            shutil.move(output_path, original_output_path)
        logging.info("All done.")

    def filter_reads(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Filter a Reads object'
        )

        parser.add_argument(
            'input',
            help='''Input Reads file'''
        )

        parser.add_argument(
            'output',
            nargs="?",
            help='''Output Reads file. If not provided will filter existing file directly.'''
        )

        parser.add_argument(
            '-m', '--mapped', dest='mapped',
            action='store_true',
            help='''Filter unmapped reads'''
        )
        parser.set_defaults(mapped=False)

        parser.add_argument(
            '-u', '--unique', dest='unique',
            action='store_true',
            help='''Filter reads that map multiple times (with a lower score)'''
        )
        parser.set_defaults(unique=False)

        parser.add_argument(
            '-us', '--unique-strict', dest='unique_strict',
            action='store_true',
            help='''Strictly filter reads that map multiple times (XS tag)'''
        )
        parser.set_defaults(unique_strict=False)

        parser.add_argument(
            '-q', '--quality', dest='quality',
            type=int,
            help='''Cutoff for the minimum mapping quality of a read'''
        )

        parser.add_argument(
            '-s', '--stats', dest='stats',
            help='''Path for saving stats pdf'''
        )

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.files import copy_or_expand, create_temporary_copy

        # copy file if required
        original_input_path = os.path.expanduser(args.input)
        if args.tmp:
            logging.info("Copying Reads object to temporary file...")
            input_path = create_temporary_copy(original_input_path)
            logging.info("Temporarily working in %s" % input_path)
        else:
            input_path = copy_or_expand(args.input, args.output)

        reads = kaic.Reads(file_name=input_path, mode='a')

        if args.mapped:
            logging.info("Unmapped filter enabled")
            reads.filter_unmapped(queue=True)

        if args.unique_strict:
            logging.info("Strict multi-map filter enabled")
            reads.filter_non_unique(strict=True, queue=True)
        elif args.unique:
            logging.info("Soft multi-map filter enabled")
            reads.filter_non_unique(strict=False, queue=True)

        if args.quality:
            logging.info("Quality filter enabled (%d)" % args.quality)
            reads.filter_quality(args.quality, queue=True)

        logging.info("Running filters...")
        reads.run_queued_filters(log_progress=True)
        logging.info("Done.")

        if args.stats:
            logging.info("Plotting filter statistics")
            import kaic.plotting as kaicplt
            kaicplt.plot_mask_statistics(reads, reads._reads, output=args.stats)
            logging.info("Done.")

        reads.close()

        if args.tmp:
            output_path = os.path.expanduser(args.output)
            if os.path.isdir(output_path):
                output_path = "%s/%s" % (output_path, os.path.basename(original_input_path))
            logging.info("Moving temporary output file to destination %s..." % output_path)
            shutil.move(input_path, output_path)

        logging.info("All done.")

    def build_genome(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Convenience command to build a Genome object'
        )

        parser.add_argument(
            'input',
            nargs='+',
            help=textwrap.dedent('''\
                                 Can be a FASTA file,
                                 a folder with FASTA files, or a
                                 list of FASTA files.
                                 ''')
        )

        parser.add_argument(
            'output',
            help='''Output file for Genome object'''
        )

        args = parser.parse_args(sys.argv[2:])

        genome_string = ','.join(args.input)
        output_path = os.path.expanduser(args.output)

        import kaic

        logging.info("Building Genome...")
        genome = kaic.Genome.from_string(genome_string=genome_string, file_name=output_path)
        genome.close()
        logging.info("All done.")

    def reads_to_pairs(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Convert a Reads object into a Pairs object'
        )

        parser.add_argument(
            'reads1',
            help='''First half of input reads'''
        )

        parser.add_argument(
            'reads2',
            help='''Second half of input reads'''
        )

        parser.add_argument(
            'genome',
            help=textwrap.dedent('''\
                                 Can be an HDF5 Genome object, a FASTA file,
                                 a folder with FASTA files, or a comma-separated
                                 list of FASTA files.
                                 ''')
        )

        parser.add_argument(
            'restriction_enzyme',
            help='''Restriction enzyme used in the experiment, e.g. HindIII'''
        )

        parser.add_argument(
            'output',
            help='''Output file for mapped pairs'''
        )

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.files import create_temporary_copy

        reads1_path = os.path.expanduser(args.reads1)
        # copy file if required
        if args.tmp:
            logging.info("Creating temporary copy of first half of reads...")
            reads1_path = create_temporary_copy(reads1_path)
            logging.info("Working with temporary copy %s" % reads1_path)

        reads2_path = os.path.expanduser(args.reads2)
        # copy file if required
        if args.tmp:
            logging.info("Creating temporary copy of second half of reads...")
            reads2_path = create_temporary_copy(reads2_path)
            logging.info("Working with temporary copy %s" % reads2_path)

        genome_path = os.path.expanduser(args.genome)

        output_path = os.path.expanduser(args.output)
        original_output_path = output_path
        if args.tmp:
            tmp_file = tempfile.NamedTemporaryFile(delete=False)
            tmp_file.close()
            output_path = tmp_file.name
            logging.info("Working in temporary output file %s" % output_path)

        logging.info("Loading left side of reads...")
        reads1 = kaic.Reads(reads1_path, mode='r')
        logging.info("Loading right side of reads...")
        reads2 = kaic.Reads(reads2_path, mode='r')
        logging.info("Building genome...")
        genome = kaic.Genome.from_string(genome_path)
        logging.info("Getting fragments...")
        nodes = genome.get_regions(args.restriction_enzyme)

        logging.info("Building pairs...")
        pairs = kaic.FragmentMappedReadPairs(file_name=output_path, mode='w')
        logging.info("Mapping reads...")
        pairs.load(reads1, reads2, nodes)

        reads1.close()
        reads2.close()
        pairs.close()

        if args.tmp:
            logging.info("Removing temporary input files...")
            os.unlink(reads1_path)
            os.unlink(reads2_path)
            logging.info("Moving output file to destination %s" % original_output_path)
            shutil.move(output_path, original_output_path)

        logging.info("All done.")

    def filter_pairs(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Filter a Pairs object'
        )

        parser.add_argument(
            'input',
            help='''Input FragmentMappedPairs file'''
        )

        parser.add_argument(
            'output',
            nargs="?",
            help='''Output FragmentMappedPairs file. If not provided will filter input file in place.'''
        )

        parser.add_argument(
            '-i', '--inward', dest='inward',
            type=int,
            help='''Minimum distance for inward-facing read pairs'''
        )

        parser.add_argument(
            '-o', '--outward', dest='outward',
            type=int,
            help='''Minimum distance for outward-facing read pairs'''
        )

        parser.add_argument(
            '--auto',
            action='store_true',
            help='''Auto-guess settings for inward/outward read pair filters.
                    Overrides --outward and --inward if set.'''
        )

        parser.add_argument(
            '-r', '--re-distance', dest='redist',
            type=int,
            help='''Maximum distance for a read to the nearest restriction site'''
        )

        parser.add_argument(
            '-l', '--self-ligated', dest='self_ligated',
            action='store_true',
            help='''Remove read paires representing self-ligated fragments'''
        )
        parser.set_defaults(self_ligated=False)

        parser.add_argument(
            '-d', '--duplicate', dest='dup_thresh',
            type=int,
            help='''If specified, filter read pairs for PCR duplicates. Parameter determines
                    distance between aligment starts below which they are considered Starting
                    at same position. Sensible values are between 1 and 5.'''
        )

        parser.add_argument(
            '-s', '--stats', dest='stats',
            help='''Path for saving stats pdf'''
        )

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.files import copy_or_expand, create_temporary_copy

        # copy file if required
        original_input_path = os.path.expanduser(args.input)
        if args.tmp:
            logging.info("Creating temporary copy of input file...")
            input_path = create_temporary_copy(original_input_path)
            logging.info("Working from copy in %s" % input_path)
        else:
            input_path = copy_or_expand(args.input, args.output)

        pairs = kaic.FragmentMappedReadPairs(file_name=input_path, mode='a')

        if args.auto:
            logging.info("Filtering inward- and outward-facing reads using automatically"
                         "determined thresholds.")
            pairs.filter_ligation_products(queue=True)
        else:
            if args.inward:
                logging.info("Filtering inward-facing reads at %dbp" % args.inward)
                pairs.filter_inward(minimum_distance=args.inward, queue=True)

            if args.outward:
                logging.info("Filtering outward-facing reads at %dbp" % args.outward)
                pairs.filter_outward(minimum_distance=args.outward, queue=True)

        if args.redist:
            logging.info("Filtering reads with RE distance >%dbp" % args.redist)
            pairs.filter_re_dist(args.redist, queue=True)

        if args.self_ligated:
            logging.info("Filtering self-ligated read pairs")
            pairs.filter_self_ligated(queue=True)

        if args.dup_thresh:
            logging.info("Filtering PCR duplicates, threshold <=%dbp" % args.dup_thresh)
            pairs.filter_pcr_duplicates(threshold=args.dup_thresh, queue=True)

        logging.info("Running filters...")
        pairs.run_queued_filters(log_progress=True)
        logging.info("Done.")

        if args.stats:
            logging.info("Plotting filter statistics")
            import kaic.plotting as kaicplt
            kaicplt.plot_mask_statistics(pairs, pairs._pairs, output=args.stats)
            logging.info("Done.")

        pairs.close()

        if args.tmp:
            output_path = os.path.expanduser(args.output)
            if os.path.isdir(output_path):
                output_path = "%s/%s" % (output_path, os.path.basename(original_input_path))
            logging.info("Moving temporary output file to destination %s..." % output_path)
            shutil.move(input_path, output_path)

        logging.info("All done.")

    def pairs_to_hic(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Convert a pairs object into a Hic object'
        )

        parser.add_argument(
            'pairs',
            help='''Input FragmentMappedReadPairs file'''
        )

        parser.add_argument(
            'hic',
            help='''Output path for Hic file'''
        )

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.files import create_temporary_copy

        original_pairs_path = os.path.expanduser(args.pairs)
        original_hic_path = os.path.expanduser(args.hic)
        if args.tmp:
            logging.info("Creating temporary copy of input file...")
            pairs_path = create_temporary_copy(original_pairs_path)
            logging.info("Woring from temporary input file %s" % pairs_path)
            tmp_file = tempfile.NamedTemporaryFile(delete=False)
            tmp_file.close()
            hic_path = tmp_file.name
            logging.info("Working in temporary output file %s" % hic_path)
        else:
            pairs_path = original_pairs_path
            hic_path = original_hic_path

        logging.info("Loading pairs...")
        pairs = kaic.FragmentMappedReadPairs(pairs_path, mode='r')
        logging.info("Done.")

        logging.info("Adding pairs to Hic...")
        hic = kaic.Hic(hic_path, mode='w')
        hic.load_read_fragment_pairs(pairs)
        logging.info("Done.")

        pairs.close()
        hic.close()

        if args.tmp:
            logging.info("Removing temporary input file...")
            os.unlink(pairs_path)
            logging.info("Moving output file to destination %s" % original_hic_path)
            shutil.move(hic_path, original_hic_path)

        logging.info("All done.")

    def merge_hic(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Merge multiple Hic objects'
        )

        parser.add_argument(
            'hic',
            nargs='+',
            help='''Input Hic files'''
        )

        parser.add_argument(
            'output',
            help='''Output binned Hic object'''
        )

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.files import copy_or_expand, create_temporary_copy

        original_output_path = os.path.expanduser(args.output)
        if args.tmp:
            logging.info("Working in temporary directory...")
            tmp_file = tempfile.NamedTemporaryFile(delete=False)
            tmp_file.close()
            output_path = tmp_file.name
            logging.info("Temporary output file: %s" % output_path)
        else:
            output_path = original_output_path

        logging.info("Copying to %s" % output_path)
        base_path = copy_or_expand(args.hic.pop(0), output_path)
        merged = kaic.Hic(base_path, mode='a')

        for path in args.hic:
            logging.info("Merging %s" % path)
            if args.tmp:
                input_path = create_temporary_copy(path)
            else:
                input_path = os.path.expanduser(path)
            hic = kaic.Hic(input_path)
            merged.merge(hic)
            hic.close()

            if args.tmp:
                logging.info("Removing temporary file...")
                os.unlink(input_path)

        merged.close()

        if args.tmp:
            logging.info("Moving temporary output to destination %s" % original_output_path)
            shutil.move(base_path, original_output_path)
        logging.info("All done")

    def filter_hic(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Filter a Hic object'
        )

        parser.add_argument(
            'input',
            help='''Input Hic file'''
        )

        parser.add_argument(
            'output',
            nargs="?",
            help='''Output Hic file. If not provided will filter input file in place.'''
        )

        parser.add_argument(
            '-l', '--low-coverage', dest='low',
            type=float,
            nargs='?',
            help='''Filter bins with "low coverage" (lower than specified contact threshold)'''
        )

        parser.add_argument(
            '-ld', '--low-coverage-default', dest='low_default',
            action='store_true',
            help='''Filter bins with "low coverage" (under 10%% of median coverage for all non-zero bins)'''
        )
        parser.set_defaults(low_default=False)

        parser.add_argument(
            '-d', '--diagonal', dest='diagonal',
            type=int,
            help='''Filter bins along the diagonal up to this specified distance'''
        )

        parser.add_argument(
            '-s', '--stats', dest='stats',
            help='''Path for saving stats pdf'''
        )

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.files import copy_or_expand, create_temporary_copy

        original_input_path = os.path.expanduser(args.input)
        if args.tmp:
            logging.info("Creating temporary copy of input file...")
            input_path = create_temporary_copy(original_input_path)
            logging.info("Working from copy in %s" % input_path)
        else:
            input_path = copy_or_expand(args.input, args.output)

        hic = kaic.Hic(file_name=input_path, mode='a')

        if args.low_default:
            if args.low:
                logging.info("Already specified an exact cutoff with -l, skipping -ld...")
            else:
                logging.info("Filtering low-coverage bins at 10%%")
                hic.filter_low_coverage_regions(queue=True)

        if args.low is not None:
            logging.info("Filtering low-coverage bins at %d" % args.low)
            hic.filter_low_coverage_regions(cutoff=args.low, queue=True)

        if args.diagonal is not None:
            logging.info("Filtering diagonal at distance %d" % args.diagonal)
            hic.filter_diagonal(distance=args.diagonal, queue=True)

        logging.info("Running filters...")
        hic.run_queued_filters(log_progress=True)
        logging.info("Done.")

        if args.stats:
            logging.info("Plotting filter statistics")
            import kaic.plotting as kaicplt
            kaicplt.plot_mask_statistics(hic, hic._edges, output=args.stats)
            logging.info("Done.")

        hic.close()

        if args.tmp:
            output_path = os.path.expanduser(args.output)
            if os.path.isdir(output_path):
                output_path = "%s/%s" % (output_path, os.path.basename(original_input_path))
            logging.info("Moving temporary output file to destination %s..." % output_path)
            shutil.move(input_path, output_path)

        logging.info("All done.")

    def bin_hic(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Bin a Hic object into same-size regions'
        )

        parser.add_argument(
            'hic',
            help='''Input Hic file'''
        )

        parser.add_argument(
            'output',
            help='''Output binned Hic object'''
        )

        parser.add_argument(
            'bin_size',
            type=int,
            help='''Bin size in base pairs'''
        )

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.files import create_temporary_copy

        original_output_path = os.path.expanduser(args.output)
        if args.tmp:
            input_path = create_temporary_copy(args.hic)
            logging.info("Working in temporary directory...")
            tmp_file = tempfile.NamedTemporaryFile(delete=False)
            tmp_file.close()
            output_path = tmp_file.name
            logging.info("Temporary output file: %s" % output_path)
        else:
            input_path = os.path.expanduser(args.hic)
            output_path = original_output_path

        hic = kaic.Hic(file_name=input_path, mode='r')

        logging.info("Binning at %dbp" % args.bin_size)
        binned = hic.bin(args.bin_size, file_name=output_path)

        hic.close()
        binned.close()

        if args.tmp:
            logging.info("Moving temporary output file to destination %s" % original_output_path)
            os.unlink(input_path)
            shutil.move(output_path, original_output_path)

        logging.info("All done.")

    def correct_hic(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Correct a Hic object for biases'
        )

        parser.add_argument(
            'input',
            help='''Input Hic file'''
        )

        parser.add_argument(
            'output',
            nargs="?",
            help='''Output Hic file. If not provided will filter existing file in place.'''
        )

        parser.add_argument(
            '-i', '--ice', dest='ice',
            action='store_true',
            help='''Use ICE iterative correction instead of Knight matrix balancing'''
        )
        parser.set_defaults(ice=False)

        parser.add_argument(
            '-c', '--chromosome', dest='chromosome',
            action='store_true',
            help='''Correct intra-chromosomal data individually, ignore inter-chromosomal data'''
        )
        parser.set_defaults(chromosome=False)

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.files import copy_or_expand, create_temporary_copy

        # copy file if required
        original_input_path = os.path.expanduser(args.input)
        original_output_path = os.path.expanduser(args.output)
        if args.tmp:
            logging.info("Copying data to temporary file...")
            input_path = create_temporary_copy(original_input_path)
            logging.info("Working from temporary file %s" % input_path)
            tmp_file = tempfile.NamedTemporaryFile(delete=False)
            tmp_file.close()
            output_path = tmp_file.name
            logging.info("Temporary output file: %s" % output_path)
        else:
            input_path = os.path.expanduser(args.input)
            output_path = os.path.expanduser(args.output)

        if args.ice:
            import kaic.correcting.ice_matrix_balancing as ice
            hic = kaic.Hic(file_name=input_path, mode='a')
            ice.correct(hic)
            hic.close()
            if args.tmp:
                logging.info("Moving temporary output file to destination %s" % original_output_path)
                shutil.move(input_path, original_output_path)
        else:
            import kaic.correcting.knight_matrix_balancing as knight
            hic = kaic.Hic(file_name=input_path, mode='r')
            hic_new = knight.correct(hic, only_intra_chromosomal=args.chromosome, copy=True, file_name=output_path)
            hic.close()
            hic_new.close()
            if args.tmp:
                logging.info("Moving temporary output file to destination %s" % original_output_path)
                os.unlink(input_path)
                shutil.move(output_path, original_output_path)

        logging.info("All done.")

    def call_peaks(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Call enriched peaks in a Hic object'
        )

        parser.add_argument(
            'input',
            help='''Input Hic file'''
        )

        parser.add_argument(
            'output',
            help='''Output HDF5 file'''
        )

        parser.add_argument(
            '-c', '--chromosomes', dest='chromosomes',
            nargs='+',
            help='''Chromosomes to be investigated.'''
        )

        parser.add_argument(
            '-p', '--peak-size', dest='peak_size',
            type=int,
            help='''Size of the expected peak in pixels. If not set, will be estimated to correspond to ~ 25kb.'''
        )

        parser.add_argument(
            '-w', '--width', dest='width',
            type=int,
            help='''Width of the investigated area surrounding a peak in pixels. If not set, will be estimated at p+3'''
        )

        parser.add_argument(
            '-m', '--min-dist', dest='min_dist',
            type=int,
            default=3,
            help='''Minimum distance in pixels for two loci to be considered as peaks. Default: 3'''
        )

        parser.add_argument(
            '-t', '--threads', dest='threads',
            type=int,
            default=4,
            help='''Number of threads for parallel processing. Default: 4'''
        )

        parser.add_argument(
            '-b', '--batch-size', dest='batch_size',
            type=int,
            default=500000,
            help='''Maximum number of peaks examined per process. Default: 500,000'''
        )

        parser.add_argument(
            '-o', '--observed-cutoff', dest='o_cutoff',
            type=int,
            default=1,
            help='''Minimum observed contacts at peak (in reads).'''
        )

        parser.add_argument(
            '-ll', '--lower-left-cutoff', dest='ll_cutoff',
            type=float,
            default=1.0,
            help='''Minimum enrichment of peak compared to lower-left neighborhood (observed/e_ll > cutoff).'''
        )

        parser.add_argument(
            '-z', '--horizontal-cutoff', dest='h_cutoff',
            type=float,
            default=1.0,
            help='''Minimum enrichment of peak compared to horizontal neighborhood (observed/e_h > cutoff).'''
        )

        parser.add_argument(
            '-v', '--vertical-cutoff', dest='v_cutoff',
            type=float,
            default=1.0,
            help='''Minimum enrichment of peak compared to vertical neighborhood (observed/e_v > cutoff).'''
        )

        parser.add_argument(
            '-d', '--donut-cutoff', dest='d_cutoff',
            type=float,
            default=1.0,
            help='''Minimum enrichment of peak compared to donut neighborhood (observed/e_d > cutoff).'''
        )

        parser.add_argument(
            '-i', '--inter-chromosomal', dest='inter',
            action='store_true',
            help='''If set, also find peaks in inter-chromosomal data.'''
        )
        parser.set_defaults(inter=False)

        parser.add_argument(
            '-tmp', '--work-in-tmp', dest='tmp',
            action='store_true',
            help='''Work in temporary directory'''
        )
        parser.set_defaults(tmp=False)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        import kaic.data.network as kn
        from kaic.tools.files import create_temporary_copy

        # copy file if required
        original_input_path = os.path.expanduser(args.input)
        original_output_path = os.path.expanduser(args.output)
        if args.tmp:
            logging.info("Copying data to temporary file...")
            input_path = create_temporary_copy(original_input_path)
            logging.info("Working from temporary file %s" % input_path)
            tmp_file = tempfile.NamedTemporaryFile(delete=False)
            tmp_file.close()
            output_path = tmp_file.name
            logging.info("Temporary output file: %s" % output_path)
        else:
            input_path = os.path.expanduser(args.input)
            output_path = os.path.expanduser(args.output)

        pk = kn.RaoPeakCaller(p=args.peak_size, w_init=args.width, min_locus_dist=args.min_dist,
                              observed_cutoff=args.o_cutoff, n_processes=args.threads,
                              batch_size=args.batch_size, process_inter=args.inter, e_ll_cutoff=args.ll_cutoff,
                              e_d_cutoff=args.d_cutoff, e_h_cutoff=args.h_cutoff, e_v_cutoff=args.v_cutoff)

        hic = kaic.Hic(input_path, mode='r')
        peaks, f = pk.call_peaks(hic, chromosomes=args.chromosomes, file_name=output_path)

        logging.info("Found %d potential peaks" % len(peaks))
        f.close()

        if args.tmp:
            os.unlink(input_path)
            logging.info("Moving temporary output file to destination %s" % original_output_path)
            shutil.move(output_path, original_output_path)

    def plot_ligation_err(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Plot the ligation structure biases of a Pairs object'
        )

        parser.add_argument(
            'input',
            help='''Input FragmentMappedPairs file'''
        )

        parser.add_argument(
            'output',
            nargs='?',
            help='''Output pdf'''
        )

        parser.add_argument(
            '-p', '--points', dest='points',
            type=int,
            help='''Data points that make up one increment of the x axis. More=smoother=less detail.'''
        )

        args = parser.parse_args(sys.argv[2:])

        import kaic
        import kaic.plotting as kplt

        input_path = os.path.expanduser(args.input)
        output_path = None
        if args.output:
            output_path = os.path.expanduser(args.output)

        pairs = kaic.FragmentMappedReadPairs(file_name=input_path, mode='r')
        kplt.hic_ligation_structure_biases_plot(pairs, output=output_path, sampling=args.points)
        pairs.close()

        logging.info("All done.")

    def plot_re_dist(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Plot the restriction site distance of reads in a Pairs object'
        )

        parser.add_argument(
            'input',
            help='''Input FragmentMappedPairs file'''
        )

        parser.add_argument(
            'output',
            nargs='?',
            help='''Output pdf'''
        )

        parser.add_argument(
            '-l', '--limit', dest='limit',
            type=int,
            default=10000,
            help='''Limit the plot to the first LIMIT read pairs for the sake of speed. Default 10000'''
        )

        parser.add_argument(
            '-m', '--max-dist', dest='max_dist',
            type=int,
            help='''Maximum RE site distance to include in the plot. Default: no max'''
        )

        args = parser.parse_args(sys.argv[2:])

        import kaic
        import kaic.plotting as kplt

        input_path = os.path.expanduser(args.input)
        output_path = None
        if args.output:
            output_path = os.path.expanduser(args.output)

        pairs = kaic.FragmentMappedReadPairs(file_name=input_path, mode='r')
        kplt.pairs_re_distance_plot(pairs, output=output_path, limit=args.limit, max_distance=args.max_dist)
        pairs.close()

        logging.info("All done.")

    def plot_hic_corr(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Plot the correlation of two Hic objects'
        )

        parser.add_argument(
            'hic1',
            help='''First Hi-C file'''
        )

        parser.add_argument(
            'hic2',
            help='''Second Hi-C file'''
        )

        parser.add_argument(
            'output',
            nargs="?",
            help='''Output PDF file'''
        )

        parser.add_argument(
            '-c', '--colormap', dest='colormap',
            default='viridis',
            help='''Matplotlib colormap (default: viridis)'''
        )

        args = parser.parse_args(sys.argv[2:])

        import kaic
        import kaic.plotting as kaicplt

        hic1_path = os.path.expanduser(args.hic1)
        hic2_path = os.path.expanduser(args.hic2)

        hic1 = kaic.Hic(hic1_path, mode='r')
        hic2 = kaic.Hic(hic2_path, mode='r')

        output_path = None
        if args.output:
            output_path = os.path.expanduser(args.output)

        kaicplt.hic_correlation_plot(hic1, hic2, output=output_path, colormap=args.colormap, size=15)

        hic1.close()
        hic2.close()
        logging.info("All done.")

    def plot_hic_matrix(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Plot a Hic matrix'
        )

        parser.add_argument(
            'input',
            help='''Input Hi-C file'''
        )

        parser.add_argument(
            'output',
            nargs="?",
            help='''Output PDF file'''
        )

        parser.add_argument(
            '-r', '--region', dest='region',
            help='''Region selector string (e.g. "chr1:20456-330123")'''
        )

        parser.add_argument(
            '-l', '--lower', dest='lower',
            type=float,
            default=25.0,
            help='''[0.0-100.0] Percentile, lower bound on Hi-C contact counts (for color scale, default: 25.0)'''
        )

        parser.add_argument(
            '-u', '--upper', dest='upper',
            type=float,
            default=98.0,
            help='''[0.0-100.0] Percentile, upper bound on Hi-C contact counts (for color scale, default: 98.0)'''
        )

        parser.add_argument(
            '-la', '--lower-absolute', dest='lower_abs',
            type=float,
            help='''Lower bound on Hi-C contact counts. Absolute value, if provided, overrides -l.'''
        )

        parser.add_argument(
            '-ua', '--upper-absolute', dest='upper_abs',
            type=float,
            help='''Upper bound on Hi-C contact counts. Absolute value, if provided, overrides -u.'''
        )

        parser.add_argument(
            '-c', '--colormap', dest='colormap',
            default='viridis',
            help='''Matplotlib colormap (default: viridis)'''
        )

        args = parser.parse_args(sys.argv[2:])

        import kaic
        import kaic.plotting as kaicplt

        input_path = os.path.expanduser(args.input)

        hic = kaic.Hic(input_path, mode='r')

        output_path = None
        if args.output:
            output_path = os.path.expanduser(args.output)

        if args.region is None:
            args.region = slice(0, None, None)
        kaicplt.hic_matrix_plot(hic, output=output_path, key=args.region,
                                lower_percentile=args.lower, upper_percentile=args.upper,
                                lower=args.lower_abs, upper=args.upper_abs,
                                colormap=args.colormap)
        hic.close()
        logging.info("All done.")

    def plot_hic_marginals(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Plot Hic matrix marginals'
        )

        parser.add_argument(
            'input',
            help='''Input Hi-C file'''
        )

        parser.add_argument(
            'output',
            nargs="?",
            help='''Output PDF file'''
        )

        parser.add_argument(
            '-l', '--lower', dest='lower',
            type=float,
            help='''Plot lower coverage bound at this level'''
        )

        parser.add_argument(
            '-u', '--upper', dest='upper',
            type=float,
            help='''Plot lower coverage bound at this level'''
        )

        args = parser.parse_args(sys.argv[2:])

        import kaic
        import kaic.plotting as kaicplt

        input_path = os.path.expanduser(args.input)

        hic = kaic.Hic(input_path, mode='r')

        output_path = None
        if args.output:
            output_path = os.path.expanduser(args.output)

        kaicplt.hic_marginals_plot(hic, output=output_path, lower=args.lower, upper=args.upper)
        hic.close()
        logging.info("All done.")

    def plot_diff(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Plot the difference between two Hic matrices'
        )

        parser.add_argument(
            'hic1',
            help='''Input Hi-C file 1'''
        )

        parser.add_argument(
            'hic2',
            help='''Input Hi-C file 2'''
        )

        parser.add_argument(
            'output',
            nargs="?",
            help='''Output PDF file'''
        )

        parser.add_argument(
            '-r', '--region', dest='region',
            help='''Region selector string (e.g. "chr1:20456-330123")'''
        )

        parser.add_argument(
            '-l', '--lower', dest='lower',
            type=float,
            default=25.0,
            help='''[0.0-100.0] Percentile, lower bound on Hi-C contact counts (for color scale, default: 25.0)'''
        )

        parser.add_argument(
            '-u', '--upper', dest='upper',
            type=float,
            default=98.0,
            help='''[0.0-100.0] Percentile, upper bound on Hi-C contact counts (for color scale, default: 98.0)'''
        )

        parser.add_argument(
            '-la', '--lower-absolute', dest='lower_abs',
            type=float,
            help='''Lower bound on Hi-C contact counts. Absolute value, if provided, overrides -l.'''
        )

        parser.add_argument(
            '-ua', '--upper-absolute', dest='upper_abs',
            type=float,
            help='''Upper bound on Hi-C contact counts. Absolute value, if provided, overrides -u.'''
        )

        parser.add_argument(
            '-c', '--colormap', dest='colormap',
            default='viridis',
            help='''Matplotlib colormap (default: viridis)'''
        )

        args = parser.parse_args(sys.argv[2:])

        import kaic
        import kaic.plotting as kaicplt

        input_path1 = os.path.expanduser(args.hic1)
        input_path2 = os.path.expanduser(args.hic2)

        hic1 = kaic.Hic(input_path1, mode='r')
        hic2 = kaic.Hic(input_path2, mode='r')

        output_path = None
        if args.output:
            output_path = os.path.expanduser(args.output)

        if args.region is None:
            args.region = slice(0, None, None)
        kaicplt.hic_matrix_diff_plot(hic1, hic2, output=output_path, key=args.region,
                                     lower_percentile=args.lower, upper_percentile=args.upper,
                                     lower=args.lower_abs, upper=args.upper_abs,
                                     colormap=args.colormap)
        hic1.close()
        hic2.close()
        logging.info("All done.")

    def plot_ratio(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Plot the difference between two Hic matrices'
        )

        parser.add_argument(
            'hic1',
            help='''Input Hi-C file 1'''
        )

        parser.add_argument(
            'hic2',
            help='''Input Hi-C file 2'''
        )

        parser.add_argument(
            'output',
            nargs="?",
            help='''Output PDF file'''
        )

        parser.add_argument(
            '-r', '--region', dest='region',
            help='''Region selector string (e.g. "chr1:20456-330123")'''
        )

        parser.add_argument(
            '-l', '--lower', dest='lower',
            type=float,
            default=-2.0,
            help='''Absolute lower bound on Hi-C contact counts (for color scale, default: -2)'''
        )

        parser.add_argument(
            '-u', '--upper', dest='upper',
            type=float,
            default=2.0,
            help='''Absolute upper bound on Hi-C contact counts (for color scale, default: 2)'''
        )

        parser.add_argument(
            '-c', '--colormap', dest='colormap',
            default='viridis',
            help='''Matplotlib colormap (default: viridis)'''
        )

        parser.add_argument(
            '-a', '--absolute', dest='log',
            action='store_true',
            help='''Do not plot the log ratio, but the absolute'''
        )
        parser.set_defaults(log=True)

        args = parser.parse_args(sys.argv[2:])

        import kaic
        import kaic.plotting as kaicplt

        input_path1 = os.path.expanduser(args.hic1)
        input_path2 = os.path.expanduser(args.hic2)

        hic1 = kaic.Hic(input_path1, mode='r')
        hic2 = kaic.Hic(input_path2, mode='r')

        output_path = None
        if args.output:
            output_path = os.path.expanduser(args.output)

        if args.region is None:
            args.region = slice(0, None, None)
        kaicplt.hic_matrix_ratio_plot(hic1, hic2, output=output_path, key=args.region,
                                      lower=args.lower, upper=args.upper,
                                      colormap=args.colormap, log=args.log)
        hic1.close()
        hic2.close()
        logging.info("All done.")

    def hiclib_to_kaic(self):
        parser = argparse.ArgumentParser(
            prog="kaic " + sys.argv[1],
            description='Convert a hiclib object to a Hic object'
        )

        parser.add_argument(
            'hic',
            help='''Hiclib Hi-C object'''
        )

        parser.add_argument(
            'genome',
            help='''Hiclib genome object'''
        )

        parser.add_argument(
            'output',
            help='''Output file'''
        )

        parser.add_argument(
            'resolution',
            type=int,
            help='''Resolution of the file (e.g. 100000)'''
        )

        args = parser.parse_args(sys.argv[2:])

        import kaic
        from kaic.tools.hic import load_mirny_binned_hic
        mirny = load_mirny_binned_hic(os.path.expanduser(args.hic), os.path.expanduser(args.genome), args.resolution)
        hic = kaic.Hic.from_hiclib(mirny, file_name=os.path.expanduser(args.output))
        hic.close()

        logging.info("All done.")


if __name__ == '__main__':
    Kaic()
